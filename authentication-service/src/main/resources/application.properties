# Importación opcional de variables de entorno desde un archivo .env local.
# Facilita el desarrollo local sin tener que configurar variables de sistema en el IDE.
spring.config.import=optional:file:.env[.properties]

# Nombre lógico del servicio. Este ID se usa para registrarse en Eureka
# y para que otros servicios (como el Gateway) lo encuentren por nombre (lb://authentication-service).
spring.application.name=authentication-service

# Asignación de Puerto Dinámico.
# Al establecer el puerto en 0, Spring Boot buscará un puerto libre aleatorio al arrancar.
# Esto es vital para la escalabilidad horizontal, permitiendo levantar múltiples instancias
# del mismo servicio en la misma máquina sin conflictos de puerto.
server.port=0

# Configuración del hostname para el registro en Eureka (entorno local).
eureka.instance.hostname=localhost

# ==============================================================
# BASE DE DATOS (MySQL)
# ==============================================================

# Cadena de conexión JDBC.
# Las variables ${DB_HOST_PORT}, ${DB_USER}, etc., se inyectan desde el entorno o el archivo .env.
# Se habilitan opciones para permitir la recuperación de claves públicas (necesario en drivers modernos).
spring.datasource.url=jdbc:mysql://localhost:${DB_HOST_PORT}/auth_service?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=UTC
spring.datasource.username=${DB_USER}
spring.datasource.password=${DB_PASSWORD}

# Configuración del ORM (Hibernate).
# Definimos el dialecto específico para optimizar las consultas SQL generadas.
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect

# Estrategia de generación de esquema.
# 'update': Actualiza el esquema de la BD si el modelo de entidades cambia, pero mantiene los datos.
# Nota: En producción, se recomienda usar 'validate' o herramientas de migración como Flyway.
spring.jpa.hibernate.ddl-auto=update

# Muestra las consultas SQL en la consola (útil para depuración en desarrollo).
spring.jpa.show-sql=true

# ==============================================================
# SERVICE DISCOVERY (Eureka Client)
# ==============================================================
# URL del servidor Eureka donde este servicio reportará su estado ("latidos").
eureka.client.service-url.defaultZone=http://localhost:8761/eureka/

# Identificador único de la instancia.
# Al usar puertos aleatorios (server.port=0), es crucial generar un ID único (usando random.value)
# para que Eureka distinga entre múltiples instancias del mismo servicio corriendo simultáneamente.
eureka.instance.instance-id=${spring.application.name}:${spring.application.instance_id:${random.value}}

# ==============================================================
# SEGURIDAD (JWT)
# ==============================================================
# Clave secreta para firmar los tokens. Inyectada desde variables de entorno por seguridad.
jwt.secret.key=${JWT_SECRET}

# ==============================================================
# MENSAJERÍA (Kafka Producer)
# ==============================================================

# Dirección de los brokers de Kafka.
spring.kafka.bootstrap-servers=${KAFKA_BOOTSTRAP_SERVERS}

# Configuración de reintentos en caso de fallo de envío.
spring.kafka.producer.retries=1

# Serializadores: Kafka transporta bytes.
# - La clave (Key) se serializa como String.
# - El valor (Value/Payload) se serializa como JSON usando la librería de Spring.
spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer

# Evita que Spring añada cabeceras de tipo Java (__TypeId__) al mensaje JSON.
# Esto hace que el mensaje sea más interoperable con consumidores que no sean Java/Spring.
spring.kafka.producer.properties.spring.json.add.type.headers=false